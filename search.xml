<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[RAP的使用总结]]></title>
      <url>%2F2017%2F04%2F03%2Frap%2F</url>
      <content type="text"><![CDATA[介绍RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。除了日常用到的新建接口，数据模拟，这里主要介绍一些小技巧。 技能升级显示与隐藏在编辑Mock规则时，请点击右上角的 Mock按钮来显示Mock信息 ，为了接口文档的阅读体验，默认Mock信息会被隐藏。 书写规则在备注里，Mock标签和普通的备注需要用分号隔开，比如： 某一个参数叫userId，备注信息是 用户ID, mock标签是 @mock=123，则在备注中应该填写: 用户ID;@mock=123 转义 变量名 备注 结果 escapeDemo @mock=”123” “escapeDemo” : “\”123\”” noEscapeDemo @{mock}=”123” “noEscapeDemo” : “”1,2,3”” // 语法错误 默认所有@mock的值会被转义，若不需要转义，请以 @{mock} 代替。 根据请求参数来动态生成MockJS模板通过${page}这样的语法，RAP会根据请求参数的值替换掉${page}对应的位置，page是参数名。例如：@mock=${page}表示根据请求参数page来决定mockjs模板，若请求参数page传入的是123，则这里会等价于:@mock=123 mock规则默认，RAP会为不同数据类型生成默认的数据，您也可以通过手动编写标签实现更好的Mock行为控制。您可以使用MockJS语法:mockjs语法数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：1234// 属性名 name// 生成规则 rule// 属性值 value&apos;name|rule&apos;: value 生成规则 有 7 种格式：1234567&apos;name|min-max&apos;: value&apos;name|count&apos;: value&apos;name|min-max.dmin-dmax&apos;: value&apos;name|min-max.dcount&apos;: value&apos;name|count.dmin-dmax&apos;: value&apos;name|count.dcount&apos;: value&apos;name|+step&apos;: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。比如第一条规则，当value为string的时候表示 通过重复 value 生成一个字符串，重复次数大于等于 min，小于等于 max。当value 为 number时， 表示生成一个大于等于 min、小于等于 max 的整数，属性值 value 只是用来确定类型。属性值 中可以含有 @占位符。属性值 还指定了最终值的初始值和类型。详细规则 可以查看mockjs语法规范 根据实际传参值决定所匹配接口我们经常会用到的两个接口的路径是一样的，只是path传参不同。这个时候可以使用下面这种方式：新建接口时，接口地址里面写为：12/cms/renderDataForBlockType?&#123;alias&#125;=QDH_APPLY/cms/renderDataForBlockType?&#123;alias&#125;=test 这样 在你请求的时候 会根据参数来匹配调用哪个接口,结果如下图所示： 不同模块之间的调用比如我们开始的模块id是4，想要调用id是37的模块里面的接口，这个时候只需要在4的项目中点击配置，把项目路由里新增37，各个模块之间使用逗号隔开。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo使用草稿]]></title>
      <url>%2F2017%2F03%2F27%2Fhexo%E4%BD%BF%E7%94%A8%E8%8D%89%E7%A8%BF%2F</url>
      <content type="text"><![CDATA[草稿介绍草稿是 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 新建草稿1hexo new draft &quot;My draft&quot; 通过该命令会在 source 目录下 生成_drafts/My draft.md 预览草稿草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 发表草稿到文章1$ hexo publish [layout] &lt;title&gt; // hexo publish draft My draft]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[lodash学习]]></title>
      <url>%2F2017%2F03%2F27%2Flodash%2F</url>
      <content type="text"><![CDATA[安装浏览器端直接引用: 使用 npm:12$ npm i -g npm // 可能需要root权限$ npm i --save lodash]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue开发总结及技术分享]]></title>
      <url>%2F2017%2F03%2F25%2Fvue%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[介绍vue.js优势是（视图-模型）双向绑定，简化了dom的操作（不用重写大量的html标签），提高dom的复用率（以最少代码实现更多的功能），倾向于数据读写，虽然看上去使用比较繁琐，但是利于后期的维护。 挂载点的选择el只在由 new 创建的实例中遵守。提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。在实例挂载之后， 元素可以用 vm.$el 访问。 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 &lt;html&gt; 或者 &lt;body&gt; 上。 数据绑定数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定 双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。 123&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;div v-html="rawHtml"&gt;&lt;/div&gt; 指令 指令是特殊的带有前缀 v- 特性。指令的值限定为 绑定表达式 ，它的职责是当其表达式的值改变时把某些行为应用到DOM上。 v-show 、v-if一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好 v-for123456789101112131415161718&lt;ul id="repeat-object" class="demo"&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 你也可以提供第二个的参数为键名： --&gt;&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; &lt;!-- 第三个参数为索引：--&gt;&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; v-on／@利用 v-on 指令用于监听DOM事件，例如： &lt;a v-on:click=&quot;doSomething&quot;&gt; v-bind／:利用 v-bind 指令用于响应的更新HTML属性，例如： &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt; 自定义指令除了默认设置的核心指令( v-model 和 v-show ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。下面这个例子将聚焦一个 input 元素，像这样： 12345678// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 也可以注册局部指令，组件中接受一个 directives 的选项： 12345directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus 属性：&lt;input v-focus&gt; keep-alive&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 主要用于保留组件状态或避免重新渲染。 深入响应式原理Vue 最显著的特性之一便是不太引人注意的响应式系统(reactivity system)。模型层(model)只是普通 JavaScript 对象，修改它则更新视图(view)。这会让状态管理变得非常简单且直观，不过理解它的工作原理以避免一些常见的问题也是很重要的。 把一个普通 Javascript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty 把这些属性全部转为 getter/setter。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 devtools 开发版本默认为 true，生产版本默认为 false。生产版本设为 true可以启用检查。Vue.config.devtools = (process.env.NODE_ENV !== &#39;production&#39;) set使用受现代 Javascript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。 12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上： this.$set(this.someObject,&#39;b&#39;,2) 用法： 设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象 参考： 深入响应式原理 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性： 12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) Vue 不能检测以下变动的数组：1.当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue2.当你修改数组的长度时，例如： vm.items.length = newLength 为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新 1234// Vue.setVue.set(example1.items, indexOfItem, newValue)// Array.prototype.splice`example1.items.splice(indexOfItem, 1, newValue) 避免第二种情况，使用 splice： 1example1.items.splice(newLength) vm.$nextTick()可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会一次推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MutationObserver，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: 'not updated' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; '没有更新' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; '更新完成' &#125;) &#125; &#125;&#125;) watch为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 1234567891011121314151617181920var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 方法名 b: 'someMethod', // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1 父子组件通信使用Prop 传递数据组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。 prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”： 1234567Vue.component('child', &#123; // 声明 props props: ['message'], // 就像 data 一样，prop 可以用在模板内 // 同样也可以在 vm 实例中像 “this.message” 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 然后向它传入一个普通字符串： 1&lt;child message="hello!"&gt;&lt;/child&gt; 如果是动态属性 1&lt;child :message="hello!"&gt;&lt;/child&gt; 自定义事件父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！ 使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件 下面是一个例子： 12345&lt;div id="counter-event-example"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment="incrementTotal"&gt;&lt;/button-counter&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627Vue.component('button-counter', &#123; template: '&lt;button v-on:click="increment"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 单向数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。 通常有两种改变 prop 的情况：1.prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；2.prop 作为需要被转变的原始值传入。更确切的说这两种情况是： 123456789101112// 1.定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125;// 2.定义一个 computed 属性，此属性从 prop 的值计算得出。props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 异步组件在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。 123456Vue.component('async-webpack-example', function (resolve) &#123; // 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve)&#125;) 比如 路由 当打包构建应用时，Javascript包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 这种异步加载组件的写法 会生成类似 11.11.js 这样的的文件。在需要渲染的时候再加载 扩展路由 vue-router使用步骤123456789101112131415161718192021222324252627// 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)import VueRouter from 'vue-router' Vue.use(VueRouter)// 定义（路由）组件。// 可以从其他文件 import 进来const componentA = resolve =&gt; require(['./componentA/index'], resolve)const componentB = resolve =&gt; require(['./componentB/index'], resolve)// 创建 router 实例 const router = new VueRouter(&#123; mode: 'hash', base: __dirname, routes: [&#123; path: '/', component: componentA, name: 'aaa', meta: &#123; title: 'aaa' &#125; &#125;]&#125;) // 创建和挂载根实例。new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 导航钩子123router.beforeEach((to, from, next) =&gt; &#123; // to 和 from 都是 路由信息对象&#125;) -&gt;更多 vuex每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： 1.Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 2.你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 1234567891011121314151617import Vue from 'vue'import Vuex from 'vuex'// import &#123; state, mutations &#125; from './mutations'Vue.use(Vuex)const store = new Vuex.Store(&#123; strict: process.env.NODE_ENV !== 'production',//在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。 state: &#123; data: '' &#125;, mutations: &#123; saveData(state, obj) &#123; state.data = obj &#125; &#125;&#125;) 现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更 赋值 this.$store.commit(&#39;saveData&#39;, obj) 取值 this.$store.state.data 再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。 由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutations。 -&gt; 更多 注意1.顶层的元素不能是组件2.组件模板应只包含一个根元素 computed 为对象123456789computed: &#123; songWithExtraStuff () &#123; const song = this.song return &#123; ...song, duration: max(song.tracks.map(track =&gt; track.duration)) &#125; &#125;&#125; 参考链接vue官方文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo + github搭建博客]]></title>
      <url>%2F2017%2F03%2F25%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[准备工具Node.jsGit 开始接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 搭建博客安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件 1$ hexo init &lt;folder&gt; 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 部署配置为了能直接打包文件到github，我们需要安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 打开要部署到 git上 ，还需要修改_config.ymltype:git ,repo 为 git 仓库地址,如:123deploy:- type: git repo: git@github.com:[YOURUSERNAME]/[YOURUSERNAME].github.io.git 最后终于配置完了，跑如下命令，能直接生成博客内容到git中123456789$ hexo generate --deploy 或 $ hexo deploy --generate// 也可以简写为$ hexo g -d或$ hexo d -g 然后就可以通过此域名访问博客了https://[YOURUSERNAME].github.io 参考链接hexo官方文档]]></content>
    </entry>

    
  
  
</search>
